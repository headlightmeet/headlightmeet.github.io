import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as l,d as e}from"./app-DeYunnnJ.js";const a={},n=e(`<h1 id="常规" tabindex="-1"><a class="header-anchor" href="#常规"><span>常规</span></a></h1><h2 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型"><span>基本数据类型</span></a></h2><ul><li><p>number 数字类型</p></li><li><p>string 字符串类型</p></li><li><p>boolean 布尔值类型 步林</p></li><li><p>object 对象类型</p></li><li><p>undefined 为定义类型</p></li><li><p>null 空值类型</p></li><li><p>symbol 唯一类型(符号) 升波</p></li><li><p>BigInt 数字类型 比紧特</p></li><li><p>基本类型：String、Number、Boolean、Symbol、Undefined、Null</p></li><li><p>引用类型：Object</p></li></ul><h2 id="基本函数" tabindex="-1"><a class="header-anchor" href="#基本函数"><span>基本函数</span></a></h2><ul><li>截断：slice(),开始位置的索引(从0开始)</li><li>删除：splice()(丝不来丝)</li><li>转数组：split() 丝不来特</li><li>转字符串：join()，toString()</li><li>JSON.stringify(obj) (丝准的怀) 转json字符串</li><li>JSON.parse(_obj) (破儿丝) 转json对象</li></ul><h2 id="this指向的含义" tabindex="-1"><a class="header-anchor" href="#this指向的含义"><span>this指向的含义</span></a></h2><ul><li>在全局函数中，this等于window，</li><li>在函数被作为某个对象调用时，this等于那个对象</li></ul><p>不过，匿名函数具有全局性，因此this对象同常指向window</p><h2 id="js变量提升" tabindex="-1"><a class="header-anchor" href="#js变量提升"><span>JS变量提升</span></a></h2><p>在函数作用域或者全局作用域中，通过var声明的变量，无论在哪里声明，都会被当做成在当前作用域或顶部声明，这就是函数提升</p><h2 id="localstorage、sessionstorage与cookie区别" tabindex="-1"><a class="header-anchor" href="#localstorage、sessionstorage与cookie区别"><span>localStorage、sessionStorage与cookie区别</span></a></h2><h3 id="localstorage" tabindex="-1"><a class="header-anchor" href="#localstorage"><span>localStorage</span></a></h3><p>localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据</p><h3 id="sessionstorage" tabindex="-1"><a class="header-anchor" href="#sessionstorage"><span>sessionStorage</span></a></h3><p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的</p><h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie"><span>cookie</span></a></h3><ul><li>大小只有4kb</li><li>跨域不能共享</li><li>不安全，容易被劫持</li><li>只存在请求头中</li></ul><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h2><p><strong>定义：内部函数的作用域链依然保持着对父函数活动对象的引用，就是闭包</strong></p><p>闭包有两个作用：</p><ul><li>第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）</li><li>第二个就是让这些外部变量始终保存在内存中</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> lives</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 50</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    lives</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> -=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="什么是闭包" tabindex="-1"><a class="header-anchor" href="#什么是闭包"><span>什么是闭包？</span></a></h3><ul><li>函数内嵌套函数</li><li>子函数引用了父函数的相关变量</li></ul><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p><strong>闭包优点：</strong></p><ul><li>创建全局私有变量，避免变量全局污染</li><li>可以实现封装、缓存等 <strong>闭包缺点：</strong></li><li>创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出 解决： 在不需要使用的时候把变量设为null <strong>使用场景：</strong></li><li>常用来封装组件和插件，比如：表单操作和倒计时功能等等</li></ul><h3 id="闭包一定会造成内存泄漏吗" tabindex="-1"><a class="header-anchor" href="#闭包一定会造成内存泄漏吗"><span>闭包一定会造成内存泄漏吗？</span></a></h3><p>闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。</p><h2 id="var、let和const的区别" tabindex="-1"><a class="header-anchor" href="#var、let和const的区别"><span>var、let和const的区别</span></a></h2><ul><li>var可以重复声明，全局调用，没有块级作用域</li><li>let不能重复声明，有块级作用域，变量可以修改</li><li>const 不能重复声明，有块级作用域，常量不可以修改</li></ul><p>暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区</p><h2 id="解释null和undefined" tabindex="-1"><a class="header-anchor" href="#解释null和undefined"><span>解释null和undefined</span></a></h2><p>JavaScript 中有两种底层类型：null 和 undefined。它们代表了不同的含义：</p><ul><li>尚未初始化：undefined；</li><li>空值：null。</li></ul><h2 id="for-in和for-of的区别" tabindex="-1"><a class="header-anchor" href="#for-in和for-of的区别"><span>for in和for of的区别</span></a></h2><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用</li></ul><h2 id="foreach和map方法有什么区别" tabindex="-1"><a class="header-anchor" href="#foreach和map方法有什么区别"><span>forEach和map方法有什么区别</span></a></h2><p>两个方法都是用来遍历循环数组，区别如下：</p><ul><li>forEach()对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="轮询" tabindex="-1"><a class="header-anchor" href="#轮询"><span>轮询</span></a></h2><p>定义：就是每隔一个固定的时间就向后端发起一个异步请求。 常用到的方式：setTimeout和setInterval,clearTimeout (克尼尔特闷欧特),clearInterval (克里尔因特儿佛)</p><h3 id="setinterval方式" tabindex="-1"><a class="header-anchor" href="#setinterval方式"><span>setInterval方式：</span></a></h3><p>优点：就是写法简单； 缺点：就是无限的循环，不太好把控。</p><p>总的来说轮询会比较浪费网络资源，而且不管请求有没有响应，都会接着发下一次请求，影响性能。</p><h3 id="长轮询" tabindex="-1"><a class="header-anchor" href="#长轮询"><span>长轮询</span></a></h3><p>定义：就是下一次请求的发出的前提条件就是前一次请求响应成功。 通常采用promise语法来写</p><h2 id="定时器" tabindex="-1"><a class="header-anchor" href="#定时器"><span>定时器</span></a></h2><h3 id="一次性定时器" tabindex="-1"><a class="header-anchor" href="#一次性定时器"><span>一次性定时器</span></a></h3><p>setTimeout(callback, delay, rest) (色特特闷欧特) self.time = setTimeout(() =&gt; {</p><p>}, 1000);</p><h3 id="取消定时器-cleartimeout-克尼尔特闷欧特" tabindex="-1"><a class="header-anchor" href="#取消定时器-cleartimeout-克尼尔特闷欧特"><span>取消定时器 clearTimeout (克尼尔特闷欧特)</span></a></h3><p>clearTimeout(self.time)</p><h3 id="定时加载定时器" tabindex="-1"><a class="header-anchor" href="#定时加载定时器"><span>定时加载定时器</span></a></h3><p>setInterval(callback, delay, rest) (色特因特儿佛) self.time = setInterval(() =&gt; {</p><p>}, 1000);</p><h3 id="取消定时器-clearinterval-克里尔因特儿佛" tabindex="-1"><a class="header-anchor" href="#取消定时器-clearinterval-克里尔因特儿佛"><span>取消定时器 clearInterval (克里尔因特儿佛)</span></a></h3><p>clearInterval(self.time)</p><h2 id="事件委托" tabindex="-1"><a class="header-anchor" href="#事件委托"><span>事件委托</span></a></h2><p>什么是事件委托：通俗的讲，事件就是onclick，onmouseover，onmouseout，等就是事件，委托呢，就是让别人来做，这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件。 也就是：利用冒泡的原理，把事件加到父级上，触发执行效果。</p><p>好处：</p><ul><li>1、提高性能</li><li>2、新添加的原生还会有之前的事件</li></ul><h2 id="常见状态码含义" tabindex="-1"><a class="header-anchor" href="#常见状态码含义"><span>常见状态码含义</span></a></h2><ul><li>1××开头 - 信息性状态码，表示HTTP请求已被接收，需要进一步处理</li><li>2××开头 - 成功状态码，表示请求已成功处理完成。</li><li>3××开头 - 重定向状态码，表示请求需要进一步的操作以完成。</li><li>4××开头 - 客户端错误状态码，表示请求包含错误或无法完成。</li><li>5××开头 - 服务器错误状态码，表示服务器无法完成有效的请求。</li></ul><h2 id="http请求-报文-都有什么组成" tabindex="-1"><a class="header-anchor" href="#http请求-报文-都有什么组成"><span>HTTP请求(报文)都有什么组成？</span></a></h2><p>HTTP请求报文主要由三个部分组成：<strong>请求行、请求头和请求体</strong>。具体如下：</p><ul><li>请求行：包含请求方法、URI（请求的资源路径）和HTTP协议版本。例如：GET /index.html HTTP/1.1。</li><li>请求头（Header）: 包含请求的元信息，如Host、User-Agent、Accept等。</li><li>请求体（Body） : 存放请求参数。</li></ul><p><strong>注意:并不是所有的HTTP请求都必须带有请求体，像GET请求通常不需要发送请求体</strong></p><h2 id="tcp和udp协议" tabindex="-1"><a class="header-anchor" href="#tcp和udp协议"><span>TCP和UDP协议</span></a></h2><ul><li>UDP：在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。</li><li>TCP： 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li></ul><h2 id="说明-和-之间的区别" tabindex="-1"><a class="header-anchor" href="#说明-和-之间的区别"><span>说明<code>==</code>和<code>===</code>之间的区别？</span></a></h2><p><code>==</code>仅检查值相等，而<code>===</code>是一个更严格的等式判定，如果两个变量的值或类型不同，则返回false。</p><h2 id="什么是全局变量-这些变量如何声明-使用全局变量有哪些问题" tabindex="-1"><a class="header-anchor" href="#什么是全局变量-这些变量如何声明-使用全局变量有哪些问题"><span>什么是全局变量？这些变量如何声明，使用全局变量有哪些问题？</span></a></h2><p>全局变量是整个代码长度可用的变量，也就是说这些变量没有任何作用域。var关键字用于声明局部变量或对象。如果省略var关键字，则声明一个全局变量。</p><h2 id="解构赋值" tabindex="-1"><a class="header-anchor" href="#解构赋值"><span>解构赋值</span></a></h2><ul><li>1、左右两边结构必须一样</li><li>2、右边必须是个东西</li><li>3、声明和赋值不能分开（必须在一句话里完成） <strong>案例二</strong></li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">d</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.1</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">og</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="为什么0-1-0-2-0-3-如何让其相等" tabindex="-1"><a class="header-anchor" href="#为什么0-1-0-2-0-3-如何让其相等"><span>为什么0.1+0.2 ! == 0.3，如何让其相等</span></a></h2><p>因为浮点数运算的精度问题。在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。 因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成0.30000000000000004，所以在计算时会产生误差</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><ul><li>将其先转换成整数，再相加之后转回小数。具体做法为先乘10相加后除以10</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0.1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0.2</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用number对象的toFixed方法，只保留一位小数点</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">n1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> n2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toFixed</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="设计模式知道那些-具体用法" tabindex="-1"><a class="header-anchor" href="#设计模式知道那些-具体用法"><span>设计模式知道那些？具体用法</span></a></h2><ul><li>单例模式：就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</li><li>观察者模式: 观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</li><li>工厂模式：解决了重复实例化的问题，缺点，创建不同对象其中属性和方法都会重复建立，消耗内存；还有函数识别问题等等。</li></ul><h2 id="栈-堆-队列" tabindex="-1"><a class="header-anchor" href="#栈-堆-队列"><span>栈，堆，队列</span></a></h2><ul><li>栈：先进后出</li><li>堆：动态分配，无特定顺序</li><li>队列：先进先出</li></ul>`,88),t=[n];function h(r,p){return l(),s("div",null,t)}const o=i(a,[["render",h],["__file","1、常规.html.vue"]]),c=JSON.parse('{"path":"/%E7%9F%A5%E8%AF%86%E5%BA%93/JS/1%E3%80%81%E5%B8%B8%E8%A7%84.html","title":"常规","lang":"zh-CN","frontmatter":{"title":"常规","order":1,"description":"常规 基本数据类型 number 数字类型 string 字符串类型 boolean 布尔值类型 步林 object 对象类型 undefined 为定义类型 null 空值类型 symbol 唯一类型(符号) 升波 BigInt 数字类型 比紧特 基本类型：String、Number、Boolean、Symbol、Undefined、Null 引用类...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E7%9F%A5%E8%AF%86%E5%BA%93/JS/1%E3%80%81%E5%B8%B8%E8%A7%84.html"}],["meta",{"property":"og:site_name","content":"向前有光的博客"}],["meta",{"property":"og:title","content":"常规"}],["meta",{"property":"og:description","content":"常规 基本数据类型 number 数字类型 string 字符串类型 boolean 布尔值类型 步林 object 对象类型 undefined 为定义类型 null 空值类型 symbol 唯一类型(符号) 升波 BigInt 数字类型 比紧特 基本类型：String、Number、Boolean、Symbol、Undefined、Null 引用类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-03T07:46:09.000Z"}],["meta",{"property":"article:author","content":"Mr.Liu"}],["meta",{"property":"article:modified_time","content":"2025-03-03T07:46:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常规\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-03T07:46:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Liu\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"基本数据类型","slug":"基本数据类型","link":"#基本数据类型","children":[]},{"level":2,"title":"基本函数","slug":"基本函数","link":"#基本函数","children":[]},{"level":2,"title":"this指向的含义","slug":"this指向的含义","link":"#this指向的含义","children":[]},{"level":2,"title":"JS变量提升","slug":"js变量提升","link":"#js变量提升","children":[]},{"level":2,"title":"localStorage、sessionStorage与cookie区别","slug":"localstorage、sessionstorage与cookie区别","link":"#localstorage、sessionstorage与cookie区别","children":[{"level":3,"title":"localStorage","slug":"localstorage","link":"#localstorage","children":[]},{"level":3,"title":"sessionStorage","slug":"sessionstorage","link":"#sessionstorage","children":[]},{"level":3,"title":"cookie","slug":"cookie","link":"#cookie","children":[]}]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[{"level":3,"title":"什么是闭包？","slug":"什么是闭包","link":"#什么是闭包","children":[]},{"level":3,"title":"闭包一定会造成内存泄漏吗？","slug":"闭包一定会造成内存泄漏吗","link":"#闭包一定会造成内存泄漏吗","children":[]}]},{"level":2,"title":"var、let和const的区别","slug":"var、let和const的区别","link":"#var、let和const的区别","children":[]},{"level":2,"title":"解释null和undefined","slug":"解释null和undefined","link":"#解释null和undefined","children":[]},{"level":2,"title":"for in和for of的区别","slug":"for-in和for-of的区别","link":"#for-in和for-of的区别","children":[]},{"level":2,"title":"forEach和map方法有什么区别","slug":"foreach和map方法有什么区别","link":"#foreach和map方法有什么区别","children":[]},{"level":2,"title":"轮询","slug":"轮询","link":"#轮询","children":[{"level":3,"title":"setInterval方式：","slug":"setinterval方式","link":"#setinterval方式","children":[]},{"level":3,"title":"长轮询","slug":"长轮询","link":"#长轮询","children":[]}]},{"level":2,"title":"定时器","slug":"定时器","link":"#定时器","children":[{"level":3,"title":"一次性定时器","slug":"一次性定时器","link":"#一次性定时器","children":[]},{"level":3,"title":"取消定时器  clearTimeout  (克尼尔特闷欧特)","slug":"取消定时器-cleartimeout-克尼尔特闷欧特","link":"#取消定时器-cleartimeout-克尼尔特闷欧特","children":[]},{"level":3,"title":"定时加载定时器","slug":"定时加载定时器","link":"#定时加载定时器","children":[]},{"level":3,"title":"取消定时器 clearInterval  (克里尔因特儿佛)","slug":"取消定时器-clearinterval-克里尔因特儿佛","link":"#取消定时器-clearinterval-克里尔因特儿佛","children":[]}]},{"level":2,"title":"事件委托","slug":"事件委托","link":"#事件委托","children":[]},{"level":2,"title":"常见状态码含义","slug":"常见状态码含义","link":"#常见状态码含义","children":[]},{"level":2,"title":"HTTP请求(报文)都有什么组成？","slug":"http请求-报文-都有什么组成","link":"#http请求-报文-都有什么组成","children":[]},{"level":2,"title":"TCP和UDP协议","slug":"tcp和udp协议","link":"#tcp和udp协议","children":[]},{"level":2,"title":"说明==和===之间的区别？","slug":"说明-和-之间的区别","link":"#说明-和-之间的区别","children":[]},{"level":2,"title":"什么是全局变量？这些变量如何声明，使用全局变量有哪些问题？","slug":"什么是全局变量-这些变量如何声明-使用全局变量有哪些问题","link":"#什么是全局变量-这些变量如何声明-使用全局变量有哪些问题","children":[]},{"level":2,"title":"解构赋值","slug":"解构赋值","link":"#解构赋值","children":[]},{"level":2,"title":"为什么0.1+0.2 ! == 0.3，如何让其相等","slug":"为什么0-1-0-2-0-3-如何让其相等","link":"#为什么0-1-0-2-0-3-如何让其相等","children":[{"level":3,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]}]},{"level":2,"title":"设计模式知道那些？具体用法","slug":"设计模式知道那些-具体用法","link":"#设计模式知道那些-具体用法","children":[]},{"level":2,"title":"栈，堆，队列","slug":"栈-堆-队列","link":"#栈-堆-队列","children":[]}],"git":{"createdTime":1720591787000,"updatedTime":1740987969000,"contributors":[{"name":"jitems","email":"3119125794@qq.com","commits":1}]},"readingTime":{"minutes":7.77,"words":2332},"filePathRelative":"知识库/JS/1、常规.md","localizedDate":"2024年7月10日","excerpt":"\\n<h2>基本数据类型</h2>\\n<ul>\\n<li>\\n<p>number      数字类型</p>\\n</li>\\n<li>\\n<p>string        字符串类型</p>\\n</li>\\n<li>\\n<p>boolean      布尔值类型  步林</p>\\n</li>\\n<li>\\n<p>object        对象类型</p>\\n</li>\\n<li>\\n<p>undefined    为定义类型</p>\\n</li>\\n<li>\\n<p>null          空值类型</p>\\n</li>\\n<li>\\n<p>symbol\\t\\t\\t唯一类型(符号)  升波</p>\\n</li>\\n<li>\\n<p>BigInt    数字类型 比紧特</p>\\n</li>\\n<li>\\n<p>基本类型：String、Number、Boolean、Symbol、Undefined、Null</p>\\n</li>\\n<li>\\n<p>引用类型：Object</p>\\n</li>\\n</ul>","autoDesc":true}');export{o as comp,c as data};
