import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as i,d as t}from"./app-BEtdDjVb.js";const a={},n=t(`<h1 id="vue-router是什么" tabindex="-1"><a class="header-anchor" href="#vue-router是什么"><span>vue-Router是什么</span></a></h1><p>Vue Router 是 Vue.js 官方的路由管理库，用于构建单页应用程序。</p><p>##　路由配置 是通过 routes 数组定义路由映射</p><h2 id="路由模式" tabindex="-1"><a class="header-anchor" href="#路由模式"><span>路由模式</span></a></h2><p><strong>Hash 模式</strong>：URL 中使用 #（默认模式），兼容性好。 <strong>History 模式</strong>(黑丝觉)：基于 HTML5 History API，URL 更美观，需服务器支持。</p><h2 id="路由守卫" tabindex="-1"><a class="header-anchor" href="#路由守卫"><span>路由守卫</span></a></h2><p><strong>全局守卫</strong></p><ul><li>全局前置守卫router.beforeEach</li><li>全局解析守卫：router.beforeResolve(比否儿 瑞日哦呜)</li><li>全局后置守卫：router.afterEach(啊斧特儿 一起)</li></ul><p><strong>beforeEach(to,from, next)</strong> 在路由跳转前触发，参数包括to,from,next(莱克斯特) 三个，这个钩子作用主要是用于登录验证 前置守卫也可以理解为一个路由拦截器，也就是说所有的路由在跳转前都要先被前置守卫拦截</p><p><strong>beforeResolve(to,from, next)</strong> 在每次导航时都会触发</p><p><strong>afterEach(to,from)</strong> 和beforeEach相反，他是在路由跳转完成后触发，参数包括to, from 由于此时路由已经完成跳转 所以不会再有next。</p><p>全局后置守卫对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。</p><p><strong>路由独享守卫</strong>：beforeEnter。 beforeEnter(to,from, next) 独享路由守卫可以直接在路由配置上定义，但是它只在进入路由时触发</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;/users/:id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">UserDetails</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 在路由配置中定义守卫</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    beforeEnter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      next</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>组件内守卫</strong></p><ul><li>beforeRouteEnter(to,from, next) -- 进入前</li><li>beforeRouteUpdate(to,from, next) -- 路由变化时</li><li>beforeRouteLeave(to,from, next)(比否儿 如特儿 礼物) -- 离开后</li></ul><h2 id="如何传递路由参数" tabindex="-1"><a class="header-anchor" href="#如何传递路由参数"><span>如何传递路由参数？</span></a></h2><p>通过动态路由参数（params(陪润儿丝)）或查询参数（query）</p><h2 id="全局路由拦截怎么做" tabindex="-1"><a class="header-anchor" href="#全局路由拦截怎么做"><span>全局路由拦截怎么做？</span></a></h2><p>beforeEach在路由跳转前触发，这个钩子作用主要是用于登录验证，前置守卫也可以理解为一个路由拦截器，也就是说所有的路由在跳转前都要先被前置守卫拦截</p><h2 id="如何监听路由变化" tabindex="-1"><a class="header-anchor" href="#如何监听路由变化"><span>如何监听路由变化？</span></a></h2><p>使用 watch 监听 $route 对象</p><h2 id="如何实现权限控制" tabindex="-1"><a class="header-anchor" href="#如何实现权限控制"><span>如何实现权限控制？</span></a></h2><p>使用全局守卫 beforeEach 检查用户权限，决定是否允许跳转。</p><h2 id="如何处理-404-页面" tabindex="-1"><a class="header-anchor" href="#如何处理-404-页面"><span>如何处理 404 页面？</span></a></h2><p>使用通配符路由匹配未定义的路由。</p><h2 id="如何实现动态路由" tabindex="-1"><a class="header-anchor" href="#如何实现动态路由"><span>如何实现动态路由？</span></a></h2><p>根据用户权限动态添加路由。</p>`,28),r=[n];function l(h,o){return i(),s("div",null,r)}const k=e(a,[["render",l],["__file","vue-Router是什么.html.vue"]]),c=JSON.parse('{"path":"/%E7%9F%A5%E8%AF%86%E5%BA%93/vue2/vue-Router%E6%98%AF%E4%BB%80%E4%B9%88.html","title":"vue-Router是什么","lang":"zh-CN","frontmatter":{"description":"vue-Router是什么 Vue Router 是 Vue.js 官方的路由管理库，用于构建单页应用程序。 ## 路由配置 是通过 routes 数组定义路由映射 路由模式 Hash 模式：URL 中使用 #（默认模式），兼容性好。 History 模式(黑丝觉)：基于 HTML5 History API，URL 更美观，需服务器支持。 路由守卫 全...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E7%9F%A5%E8%AF%86%E5%BA%93/vue2/vue-Router%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"暖阳的博客"}],["meta",{"property":"og:title","content":"vue-Router是什么"}],["meta",{"property":"og:description","content":"vue-Router是什么 Vue Router 是 Vue.js 官方的路由管理库，用于构建单页应用程序。 ## 路由配置 是通过 routes 数组定义路由映射 路由模式 Hash 模式：URL 中使用 #（默认模式），兼容性好。 History 模式(黑丝觉)：基于 HTML5 History API，URL 更美观，需服务器支持。 路由守卫 全..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-08T10:21:46.000Z"}],["meta",{"property":"article:author","content":"Mr.Liu"}],["meta",{"property":"article:modified_time","content":"2025-02-08T10:21:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue-Router是什么\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-08T10:21:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Liu\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"路由模式","slug":"路由模式","link":"#路由模式","children":[]},{"level":2,"title":"路由守卫","slug":"路由守卫","link":"#路由守卫","children":[]},{"level":2,"title":"如何传递路由参数？","slug":"如何传递路由参数","link":"#如何传递路由参数","children":[]},{"level":2,"title":"全局路由拦截怎么做？","slug":"全局路由拦截怎么做","link":"#全局路由拦截怎么做","children":[]},{"level":2,"title":"如何监听路由变化？","slug":"如何监听路由变化","link":"#如何监听路由变化","children":[]},{"level":2,"title":"如何实现权限控制？","slug":"如何实现权限控制","link":"#如何实现权限控制","children":[]},{"level":2,"title":"如何处理 404 页面？","slug":"如何处理-404-页面","link":"#如何处理-404-页面","children":[]},{"level":2,"title":"如何实现动态路由？","slug":"如何实现动态路由","link":"#如何实现动态路由","children":[]}],"git":{"createdTime":1720591787000,"updatedTime":1739010106000,"contributors":[{"name":"jitems","email":"3119125794@qq.com","commits":1},{"name":"test","email":"email","commits":1}]},"readingTime":{"minutes":1.96,"words":588},"filePathRelative":"知识库/vue2/vue-Router是什么.md","localizedDate":"2024年7月10日","excerpt":"\\n<p>Vue Router 是 Vue.js 官方的路由管理库，用于构建单页应用程序。</p>\\n<p>##　路由配置\\n是通过 routes 数组定义路由映射</p>\\n<h2>路由模式</h2>\\n<p><strong>Hash 模式</strong>：URL 中使用 #（默认模式），兼容性好。\\n<strong>History 模式</strong>(黑丝觉)：基于 HTML5 History API，URL 更美观，需服务器支持。</p>\\n<h2>路由守卫</h2>\\n<p><strong>全局守卫</strong></p>\\n<ul>\\n<li>全局前置守卫router.beforeEach</li>\\n<li>全局解析守卫：router.beforeResolve(比否儿 瑞日哦呜)</li>\\n<li>全局后置守卫：router.afterEach(啊斧特儿 一起)</li>\\n</ul>","autoDesc":true}');export{k as comp,c as data};
