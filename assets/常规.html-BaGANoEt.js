import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as l}from"./app-CBrd23JN.js";const r={},i=l('<h1 id="常规" tabindex="-1"><a class="header-anchor" href="#常规"><span>常规</span></a></h1><h2 id="vue3响应式实现" tabindex="-1"><a class="header-anchor" href="#vue3响应式实现"><span>Vue3响应式实现</span></a></h2><p>Vue3中，响应式系统是通过ES6中的Proxy(prɑ 克 色)实现对一个对象的代理，然后设置handler(喊得冷儿).get/handler.set，在对代理对象进行操作时触发get/set，get中实现收集依赖，在set中实现派发依赖，从而达到响应式的效果。</p><h2 id="vue-3-与-vue-2-的主要区别" tabindex="-1"><a class="header-anchor" href="#vue-3-与-vue-2-的主要区别"><span>Vue 3 与 Vue 2 的主要区别</span></a></h2><ul><li>性能优化：更小的包体积、更快的渲染速度。</li><li>Composition API：(抗喷热行)逻辑复用更灵活。</li><li>响应式系统：基于 Proxy 实现，支持数组和对象动态属性。</li></ul><h2 id="ref-和-reactive-瑞-啊可特呜-的区别" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive-瑞-啊可特呜-的区别"><span>ref 和 reactive(瑞 啊可特呜) 的区别</span></a></h2><ul><li>ref：用于基本类型，通过 .value 访问。</li><li>reactive：用于对象，返回代理对象，直接访问属性</li></ul><h2 id="watch-挖起-和-watcheffect-挖起-外科特-的区别" tabindex="-1"><a class="header-anchor" href="#watch-挖起-和-watcheffect-挖起-外科特-的区别"><span>watch(挖起) 和 watchEffect(挖起 外科特) 的区别？</span></a></h2><ul><li>watch：需要显式指定监听的数据源和回调。</li><li>watchEffect：自动追踪依赖，立即执行回调。</li><li>watch 可以访问改变前后的值，watchEffect 只能获取改变后的值；</li><li>watch运行的时候 不会立即执行，值改变后才会执行，而watchEffect运行后可立即执行</li></ul><h2 id="vue-3-的-v-model-变化" tabindex="-1"><a class="header-anchor" href="#vue-3-的-v-model-变化"><span>Vue 3 的 v-model 变化</span></a></h2><p>支持多个v-model绑定，默认使用modelValue和update:modelValue</p>',11),n=[i];function c(o,h){return a(),t("div",null,n)}const d=e(r,[["render",c],["__file","常规.html.vue"]]),p=JSON.parse('{"path":"/%E7%9F%A5%E8%AF%86%E5%BA%93/vue3/%E5%B8%B8%E8%A7%84.html","title":"常规","lang":"zh-CN","frontmatter":{"description":"常规 Vue3响应式实现 Vue3中，响应式系统是通过ES6中的Proxy(prɑ 克 色)实现对一个对象的代理，然后设置handler(喊得冷儿).get/handler.set，在对代理对象进行操作时触发get/set，get中实现收集依赖，在set中实现派发依赖，从而达到响应式的效果。 Vue 3 与 Vue 2 的主要区别 性能优化：更小的包体...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E7%9F%A5%E8%AF%86%E5%BA%93/vue3/%E5%B8%B8%E8%A7%84.html"}],["meta",{"property":"og:site_name","content":"向前有光的博客"}],["meta",{"property":"og:title","content":"常规"}],["meta",{"property":"og:description","content":"常规 Vue3响应式实现 Vue3中，响应式系统是通过ES6中的Proxy(prɑ 克 色)实现对一个对象的代理，然后设置handler(喊得冷儿).get/handler.set，在对代理对象进行操作时触发get/set，get中实现收集依赖，在set中实现派发依赖，从而达到响应式的效果。 Vue 3 与 Vue 2 的主要区别 性能优化：更小的包体..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-18T06:56:26.000Z"}],["meta",{"property":"article:author","content":"Mr.Liu"}],["meta",{"property":"article:modified_time","content":"2025-02-18T06:56:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常规\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-18T06:56:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Liu\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Vue3响应式实现","slug":"vue3响应式实现","link":"#vue3响应式实现","children":[]},{"level":2,"title":"Vue 3 与 Vue 2 的主要区别","slug":"vue-3-与-vue-2-的主要区别","link":"#vue-3-与-vue-2-的主要区别","children":[]},{"level":2,"title":"ref 和 reactive(瑞 啊可特呜) 的区别","slug":"ref-和-reactive-瑞-啊可特呜-的区别","link":"#ref-和-reactive-瑞-啊可特呜-的区别","children":[]},{"level":2,"title":"watch(挖起) 和 watchEffect(挖起 外科特) 的区别？","slug":"watch-挖起-和-watcheffect-挖起-外科特-的区别","link":"#watch-挖起-和-watcheffect-挖起-外科特-的区别","children":[]},{"level":2,"title":"Vue 3 的 v-model 变化","slug":"vue-3-的-v-model-变化","link":"#vue-3-的-v-model-变化","children":[]}],"git":{"createdTime":1739861786000,"updatedTime":1739861786000,"contributors":[{"name":"jitems","email":"3119125794@qq.com","commits":1}]},"readingTime":{"minutes":1.01,"words":303},"filePathRelative":"知识库/vue3/常规.md","localizedDate":"2025年2月18日","excerpt":"\\n<h2>Vue3响应式实现</h2>\\n<p>Vue3中，响应式系统是通过ES6中的Proxy(prɑ 克 色)实现对一个对象的代理，然后设置handler(喊得冷儿).get/handler.set，在对代理对象进行操作时触发get/set，get中实现收集依赖，在set中实现派发依赖，从而达到响应式的效果。</p>\\n<h2>Vue 3 与 Vue 2 的主要区别</h2>\\n<ul>\\n<li>性能优化：更小的包体积、更快的渲染速度。</li>\\n<li>Composition API：(抗喷热行)逻辑复用更灵活。</li>\\n<li>响应式系统：基于 Proxy 实现，支持数组和对象动态属性。</li>\\n</ul>","autoDesc":true}');export{d as comp,p as data};
